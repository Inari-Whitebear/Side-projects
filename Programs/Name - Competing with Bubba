--[[
Your wondefull and well explaind description of the purpose for this ]]
local tArg = (...)

if not fs.exists( tArg[1] ) then printError("Need a valid file") end

local content = {}

local handle = fs.open( tArg[1], "r")
local fileLine = handle.readLine()

content[#content + 1] = fileLine:gsub("^%s*(.-)", "%1") -- Thanks Grav! I 'stole' this from the re-indent project :P
for fileLine in handle.readLine do
	content[#content + 1] = fileLine:gsub("^%s*(.-)", "%1") -- Thanks again! :D
end

local MBcomments = {} -- MultiBlockComments, should be line xD
local nType = ""

for i = 1, #content do
	if string.find( content[i], "%-%-%[%[" ) and nType == "" then
		local cStart = string.find( content[i], "%-%-%[%[" 
		nType = "co"

		MBcomments[#MBcomments + 1] = {}
		MBcomments[#MBcomments].lineStart = i
		MBcomments[#MBcomments].charStart = cStart
	elseif string.find( content[i], "%]%]" ) and nType == "co" then
		local cStart, cEnd = string.find( content[i], "%]%]" )
		nType = ""

		MBcomments[#MBcomments].lineEnd = i
		MBcomments[#MBcomments].charEnd = cEnd
	end
end

--[[
@myFunc
#desc_short my function works !
#desc some long story that probably end soon, actually right now
#return string output
#other Dunno if I implement this :P
]]

local tKeywords = {
	["@"] = {
		["function"] = true,
		["metatable"] = true,
		["table"] = true,
		["iterator"] = true,
		["coroutine"] = true,
		["boolean"] = true
	},
	["#"] ={
		["desc"] = true,
		["desc_short"] = true,
		["return"] = true,
		["other"] = true
	}
}

-- Map the comment's content.
local commentContent = {}

for j = 1, #MBcomment do
	local continue = false
	for i = 1, #content do
		if i == MBcomment[j].lineStart + 1 then
			commentContent[#commentContent + 1] = {}
			commentContent[#commentContent][#commentContent[#commentContent]] = content[i]
		elseif continue then
			commentContent[#commentContent][#commentContent[#commentContent]] = content[i]
		elseif i == MBcomment[j].lineEnd - 1 then
			commentContent[#commentContent][#commentContent[#commentContent]] = content[i]
			break
		end
	end
end

-- Map the list you can scroll, if its too many. Also some renaming. 
local temp = {}
local removeIndex = function( index )
	for i = 1, #content do
		if i ~= index then
			temp[#temp + 1] = content[i]
		end
	end
end

local list = {}
for i = 1, #commentContent do
	if not string.find( commentContent[1][1], "@" ) then 
		removeIndex( i )
	elseif string.find( commentContent[1][1], "@" ) then
		list[#list + 1] = string.sub( commentContent[1][1], 2, string.len( commentContent[1][1] ))
	end
end

content = temp